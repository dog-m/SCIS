digraph G {
  <program> [fillcolor="0.0 0.35 1.0" style=filled];
  <package_declaration>
  <opt_package_header>
  <package_header>
  <repeat_annotation>
  <annotation>
  <type_name>
  <primitive_type_or_id>
  <primitive_type>
  <repeat_type_component>
  <type_component>
  <dot_id>
  <opt_generic_argument>
  <generic_argument>
  <list_type_argument>
  <type_argument>
  <type_specifier>
  <repeat_dimension>
  <dimension>
  <opt_expression>
  <expression>
  <lambda_expression>
  <lambda_parameters>
  <list_lambda_parameter>
  <lambda_parameter>
  <formal_parameter>
  <repeat_variable_modifier>
  <variable_modifier>
  <opt_var_arg_specifier>
  <var_arg_specifier>
  <formal_parameter_name>
  <variable_name>
  <declared_name>
  <opt_generic_parameter>
  <generic_parameter>
  <list_type_parameter>
  <type_parameter>
  <opt_type_bound_clause>
  <type_bound_clause>
  <type_bound>
  <repeat_and_type_spec>
  <and_type_spec>
  <inferred_formal_parameter>
  <lambda_body>
  <block>
  <repeat_declaration_or_statement>
  <declaration_or_statement>
  <declaration>
  <local_variable_declaration>
  <variable_declaration>
  <repeat_modifier>
  <modifier>
  <variable_declarators>
  <list_variable_declarator+>
  <variable_declarator>
  <opt_equals_variable_initializer>
  <equals_variable_initializer>
  <variable_initializer>
  <array_initializer>
  <list_variable_initializer>
  <opt_literal>
  <literal>
  <list_variable_declarator>
  <class_declaration>
  <class_header>
  <class_name>
  <opt_extends_clause>
  <extends_clause>
  <list_type_name+>
  <list_type_name>
  <opt_implements_clause>
  <implements_clause>
  <list_qualified_name+>
  <qualified_name>
  <reference>
  <repeat_component>
  <component>
  <method_argument>
  <list_argument>
  <argument>
  <subscript>
  <class_instance_creation_expression>
  <class_or_interface_name>
  <repeat_class_or_interface_component>
  <class_or_interface_component>
  <opt_class_body>
  <class_body>
  <class_or_interface_body>
  <repeat_class_body_declaration>
  <class_body_declaration>
  <empty_declaration>
  <member_declaration>
  <method_or_constructor_declaration>
  <method_declaration>
  <method_declarator>
  <method_name>
  <list_formal_parameter>
  <opt_throws>
  <throws>
  <method_body>
  <annotation_value>
  <nested_annotation>
  <list_expression_or_nested_annotation>
  <expression_or_nested_annotation>
  <constructor_declaration>
  <constructor_declarator>
  <constructor_body>
  <type_declaration>
  <interface_declaration>
  <interface_header>
  <opt_annot_marker>
  <annot_marker>
  <interface_name>
  <interface_body>
  <enum_declaration>
  <enum_header>
  <opt_id>
  <opt_declared_name>
  <enum_body>
  <list_enum_element>
  <enum_element>
  <opt_method_argument>
  <opt_class_or_interface_body>
  <instance_initializer>
  <static_initializer>
  <field_declaration>
  <method_reference>
  <list_qualified_name>
  <statement>
  <label_statement>
  <label_name>
  <empty_statement>
  <expression_statement>
  <if_statement>
  <condition>
  <opt_else_clause>
  <else_clause>
  <switch_statement>
  <switch_block>
  <repeat_switch_alternative>
  <switch_alternative>
  <switch_label>
  <constant_expression>
  <while_statement>
  <do_statement>
  <for_statement>
  <for_init>
  <list_expression>
  <for_expression>
  <for_update>
  <for_in_statement>
  <for_in_init>
  <break_statement>
  <opt_label_name>
  <continue_statement>
  <return_statement>
  <throw_statement>
  <synchronized_statement>
  <try_statement>
  <opt_resource_specification>
  <resource_specification>
  <resource_list>
  <resource>
  <repeat_semi_resource>
  <semi_resource>
  <repeat_catch_clause>
  <catch_clause>
  <catch_type_specifier>
  <repeat_or_type_specifier>
  <or_type_specifier>
  <opt_finally_clause>
  <finally_clause>
  <assert_statement>
  <opt_assert_error_code>
  <assert_error_code>
  <opt_expression_statement_no_semi>
  <expression_statement_no_semi>
  <assignment_expression>
  <conditional_expression>
  <conditional_or_expression>
  <conditional_and_expression>
  <inclusive_or_expression>
  <exclusive_or_expression>
  <and_expression>
  <equality_expression>
  <relational_expression>
  <shift_expression>
  <additive_expression>
  <multiplicative_expression>
  <unary_expression>
  <pre_inc_dec>
  <unary_op>
  <postfix_expression>
  <primary>
  <numeric_literal>
  <character_literal>
  <string_literal>
  <boolean_literal>
  <null_literal>
  <array_creation_expression>
  <array_type_specifier>
  <repeat_dimension+>
  <opt_array_initializer>
  <repeat_post_inc_dec>
  <post_inc_dec>
  <cast_expression>
  <repeat_mult_op_unary_expression>
  <mult_op_unary_expression>
  <mult_op>
  <repeat_add_op_multiplicative_expression>
  <add_op_multiplicative_expression>
  <add_op>
  <repeat_shift_additive_expression>
  <shift_additive_expression>
  <shift_op>
  <repeat_relational_op_shift_expression>
  <relational_op_shift_expression>
  <relational_op>
  <repeat_equality_op_relational_expression>
  <equality_op_relational_expression>
  <equality_op>
  <repeat_and_equality_expression>
  <and_equality_expression>
  <repeat_or_and_expression>
  <or_and_expression>
  <repeat_or_exclusive_or_expression>
  <or_exclusive_or_expression>
  <repeat_and_inclusive_or_expression>
  <and_inclusive_or_expression>
  <repeat_or_conditional_and_expression>
  <or_conditional_and_expression>
  <repeat_conditional_choice>
  <conditional_choice>
  <assignment_operator>
  <wildcard_type>
  <opt_wildcard_type_bound>
  <wildcard_type_bound>
  <class_instance_declaration>
  <opt_annotation_value_spec>
  <annotation_value_spec>
  <annotation_value_list>
  <list_keyed_annotation_value>
  <keyed_annotation_value>
  <package_name>
  <repeat_import_declaration>
  <import_declaration>
  <imported_name>
  <package_or_type_name>
  <opt_dot_star>
  <dot_star>
  <repeat_type_declaration>

  <program> -> { <package_declaration> }
  <package_declaration> -> { <repeat_type_declaration>, <opt_package_header>, <repeat_import_declaration> }
  <opt_package_header> -> { <package_header> }
  <package_header> -> { <package_name>, <repeat_annotation> }
  <repeat_annotation> -> { <annotation> }
  <annotation> -> { <opt_annotation_value_spec>, <type_name>, <opt_literal> }
  <type_name> -> { <repeat_type_component>, <primitive_type_or_id> }
  <primitive_type_or_id> -> { <primitive_type> }
  <primitive_type> -> {  }
  <repeat_type_component> -> { <type_component> }
  <type_component> -> { <generic_argument>, <dot_id> }
  <dot_id> -> { <class_instance_declaration>, <opt_generic_argument> }
  <opt_generic_argument> -> { <generic_argument> }
  <generic_argument> -> { <list_type_argument> }
  <list_type_argument> -> { <type_argument> }
  <type_argument> -> { <wildcard_type>, <type_specifier> }
  <type_specifier> -> { <repeat_dimension>, <type_name> }
  <repeat_dimension> -> { <dimension> }
  <dimension> -> { <opt_expression> }
  <opt_expression> -> { <expression> }
  <expression> -> { <assignment_expression>, <lambda_expression> }
  <lambda_expression> -> { <lambda_body>, <lambda_parameters> }
  <lambda_parameters> -> { <list_lambda_parameter> }
  <list_lambda_parameter> -> { <lambda_parameter> }
  <lambda_parameter> -> { <inferred_formal_parameter>, <formal_parameter> }
  <formal_parameter> -> { <opt_var_arg_specifier>, <repeat_variable_modifier>, <formal_parameter_name>, <type_specifier> }
  <repeat_variable_modifier> -> { <variable_modifier> }
  <variable_modifier> -> { <annotation> }
  <opt_var_arg_specifier> -> { <var_arg_specifier> }
  <var_arg_specifier> -> {  }
  <formal_parameter_name> -> { <variable_name> }
  <variable_name> -> { <repeat_dimension>, <declared_name> }
  <declared_name> -> { <opt_generic_parameter> }
  <opt_generic_parameter> -> { <generic_parameter> }
  <generic_parameter> -> { <list_type_parameter> }
  <list_type_parameter> -> { <type_parameter> }
  <type_parameter> -> { <opt_type_bound_clause>, <repeat_annotation>, <declared_name> }
  <opt_type_bound_clause> -> { <type_bound_clause> }
  <type_bound_clause> -> { <type_bound> }
  <type_bound> -> { <repeat_and_type_spec>, <type_specifier> }
  <repeat_and_type_spec> -> { <and_type_spec> }
  <and_type_spec> -> { <type_specifier> }
  <inferred_formal_parameter> -> {  }
  <lambda_body> -> { <block>, <expression> }
  <block> -> { <opt_expression_statement_no_semi>, <repeat_declaration_or_statement> }
  <repeat_declaration_or_statement> -> { <declaration_or_statement> }
  <declaration_or_statement> -> { <statement>, <declaration>, <class_declaration> }
  <declaration> -> { <local_variable_declaration> }
  <local_variable_declaration> -> { <variable_declaration> }
  <variable_declaration> -> { <variable_declarators>, <repeat_modifier>, <type_specifier> }
  <repeat_modifier> -> { <modifier> }
  <modifier> -> { <annotation> }
  <variable_declarators> -> { <list_variable_declarator+> }
  <list_variable_declarator+> -> { <list_variable_declarator>, <variable_declarator> }
  <variable_declarator> -> { <opt_equals_variable_initializer>, <variable_name> }
  <opt_equals_variable_initializer> -> { <equals_variable_initializer> }
  <equals_variable_initializer> -> { <variable_initializer> }
  <variable_initializer> -> { <array_initializer>, <expression> }
  <array_initializer> -> { <opt_literal>, <list_variable_initializer> }
  <list_variable_initializer> -> { <variable_initializer> }
  <opt_literal> -> { <literal> }
  <literal> -> { <null_literal>, <boolean_literal>, <string_literal>, <numeric_literal>, <character_literal> }
  <list_variable_declarator> -> { <variable_declarator> }
  <class_declaration> -> { <class_body>, <class_header> }
  <class_header> -> { <opt_extends_clause>, <opt_implements_clause>, <repeat_modifier>, <class_name> }
  <class_name> -> { <declared_name> }
  <opt_extends_clause> -> { <extends_clause> }
  <extends_clause> -> { <list_type_name+> }
  <list_type_name+> -> { <list_type_name>, <type_name> }
  <list_type_name> -> { <type_name> }
  <opt_implements_clause> -> { <implements_clause> }
  <implements_clause> -> { <list_qualified_name+> }
  <list_qualified_name+> -> { <list_qualified_name>, <qualified_name> }
  <qualified_name> -> { <reference> }
  <reference> -> { <primitive_type>, <repeat_component> }
  <repeat_component> -> { <component> }
  <component> -> { <method_reference>, <method_argument>, <dot_id>, <subscript>, <dimension>, <generic_argument>, <class_instance_creation_expression> }
  <method_argument> -> { <list_argument> }
  <list_argument> -> { <argument> }
  <argument> -> { <type_specifier>, <expression> }
  <subscript> -> { <expression> }
  <class_instance_creation_expression> -> { <class_or_interface_name>, <opt_class_body>, <list_argument> }
  <class_or_interface_name> -> { <repeat_class_or_interface_component> }
  <repeat_class_or_interface_component> -> { <class_or_interface_component> }
  <class_or_interface_component> -> { <generic_argument>, <dot_id> }
  <opt_class_body> -> { <class_body> }
  <class_body> -> { <class_or_interface_body> }
  <class_or_interface_body> -> { <opt_literal>, <repeat_class_body_declaration> }
  <repeat_class_body_declaration> -> { <class_body_declaration> }
  <class_body_declaration> -> { <field_declaration>, <static_initializer>, <instance_initializer>, <empty_declaration>, <member_declaration> }
  <empty_declaration> -> {  }
  <member_declaration> -> { <type_declaration>, <method_or_constructor_declaration> }
  <method_or_constructor_declaration> -> { <constructor_declaration>, <method_declaration> }
  <method_declaration> -> { <opt_throws>, <method_declarator>, <method_body>, <type_specifier>, <repeat_modifier>, <opt_generic_parameter> }
  <method_declarator> -> { <repeat_dimension>, <method_name>, <list_formal_parameter> }
  <method_name> -> { <declared_name> }
  <list_formal_parameter> -> { <formal_parameter> }
  <opt_throws> -> { <throws> }
  <throws> -> { <list_qualified_name+> }
  <method_body> -> { <annotation_value>, <block> }
  <annotation_value> -> { <list_expression_or_nested_annotation>, <expression>, <opt_literal>, <nested_annotation> }
  <nested_annotation> -> { <annotation> }
  <list_expression_or_nested_annotation> -> { <expression_or_nested_annotation> }
  <expression_or_nested_annotation> -> { <nested_annotation>, <expression> }
  <constructor_declaration> -> { <constructor_body>, <opt_throws>, <constructor_declarator>, <repeat_modifier>, <opt_generic_parameter> }
  <constructor_declarator> -> { <list_formal_parameter>, <class_name> }
  <constructor_body> -> { <block> }
  <type_declaration> -> { <enum_declaration>, <class_declaration>, <interface_declaration> }
  <interface_declaration> -> { <interface_body>, <interface_header> }
  <interface_header> -> { <opt_extends_clause>, <opt_implements_clause>, <interface_name>, <repeat_modifier>, <opt_annot_marker> }
  <opt_annot_marker> -> { <annot_marker> }
  <annot_marker> -> {  }
  <interface_name> -> { <declared_name> }
  <interface_body> -> { <class_or_interface_body> }
  <enum_declaration> -> { <enum_body>, <enum_header> }
  <enum_header> -> { <opt_declared_name>, <opt_implements_clause>, <repeat_modifier>, <opt_id> }
  <opt_id> -> {  }
  <opt_declared_name> -> { <declared_name> }
  <enum_body> -> { <repeat_class_body_declaration>, <list_enum_element>, <opt_literal> }
  <list_enum_element> -> { <enum_element> }
  <enum_element> -> { <opt_class_or_interface_body>, <repeat_modifier>, <opt_method_argument> }
  <opt_method_argument> -> { <method_argument> }
  <opt_class_or_interface_body> -> { <class_or_interface_body> }
  <instance_initializer> -> { <block> }
  <static_initializer> -> { <block> }
  <field_declaration> -> { <variable_declaration> }
  <method_reference> -> { <opt_generic_argument> }
  <list_qualified_name> -> { <qualified_name> }
  <statement> -> { <block>, <while_statement>, <synchronized_statement>, <if_statement>, <expression_statement>, <label_statement>, <switch_statement>, <do_statement>, <try_statement>, <for_statement>, <for_in_statement>, <break_statement>, <continue_statement>, <return_statement>, <throw_statement>, <empty_statement>, <assert_statement> }
  <label_statement> -> { <statement>, <label_name> }
  <label_name> -> {  }
  <empty_statement> -> {  }
  <expression_statement> -> { <expression> }
  <if_statement> -> { <opt_else_clause>, <condition>, <statement> }
  <condition> -> { <expression> }
  <opt_else_clause> -> { <else_clause> }
  <else_clause> -> { <statement> }
  <switch_statement> -> { <switch_block>, <expression> }
  <switch_block> -> { <repeat_switch_alternative> }
  <repeat_switch_alternative> -> { <switch_alternative> }
  <switch_alternative> -> { <repeat_declaration_or_statement>, <switch_label> }
  <switch_label> -> { <constant_expression> }
  <constant_expression> -> { <expression> }
  <while_statement> -> { <statement>, <condition> }
  <do_statement> -> { <condition>, <statement> }
  <for_statement> -> { <statement>, <for_update>, <for_init>, <for_expression> }
  <for_init> -> { <local_variable_declaration>, <list_expression> }
  <list_expression> -> { <expression> }
  <for_expression> -> { <opt_expression> }
  <for_update> -> { <list_expression> }
  <for_in_statement> -> { <statement>, <for_in_init>, <expression> }
  <for_in_init> -> { <variable_name>, <repeat_modifier>, <type_specifier> }
  <break_statement> -> { <opt_label_name> }
  <opt_label_name> -> { <label_name> }
  <continue_statement> -> { <opt_label_name> }
  <return_statement> -> { <opt_expression> }
  <throw_statement> -> { <expression> }
  <synchronized_statement> -> { <statement>, <expression> }
  <try_statement> -> { <opt_finally_clause>, <repeat_catch_clause>, <opt_resource_specification>, <block> }
  <opt_resource_specification> -> { <resource_specification> }
  <resource_specification> -> { <opt_literal>, <resource_list> }
  <resource_list> -> { <repeat_semi_resource>, <resource> }
  <resource> -> { <expression>, <variable_name>, <repeat_variable_modifier>, <type_specifier> }
  <repeat_semi_resource> -> { <semi_resource> }
  <semi_resource> -> { <resource> }
  <repeat_catch_clause> -> { <catch_clause> }
  <catch_clause> -> { <variable_name>, <repeat_modifier>, <block>, <catch_type_specifier> }
  <catch_type_specifier> -> { <repeat_or_type_specifier>, <type_specifier> }
  <repeat_or_type_specifier> -> { <or_type_specifier> }
  <or_type_specifier> -> { <type_specifier> }
  <opt_finally_clause> -> { <finally_clause> }
  <finally_clause> -> { <block> }
  <assert_statement> -> { <opt_assert_error_code>, <expression> }
  <opt_assert_error_code> -> { <assert_error_code> }
  <assert_error_code> -> { <expression> }
  <opt_expression_statement_no_semi> -> { <expression_statement_no_semi> }
  <expression_statement_no_semi> -> { <expression> }
  <assignment_expression> -> { <expression>, <assignment_operator>, <conditional_expression>, <unary_expression> }
  <conditional_expression> -> { <repeat_conditional_choice>, <conditional_or_expression> }
  <conditional_or_expression> -> { <repeat_or_conditional_and_expression>, <conditional_and_expression> }
  <conditional_and_expression> -> { <repeat_and_inclusive_or_expression>, <inclusive_or_expression> }
  <inclusive_or_expression> -> { <repeat_or_exclusive_or_expression>, <exclusive_or_expression> }
  <exclusive_or_expression> -> { <repeat_or_and_expression>, <and_expression> }
  <and_expression> -> { <repeat_and_equality_expression>, <equality_expression> }
  <equality_expression> -> { <repeat_equality_op_relational_expression>, <relational_expression> }
  <relational_expression> -> { <repeat_relational_op_shift_expression>, <shift_expression> }
  <shift_expression> -> { <repeat_shift_additive_expression>, <additive_expression> }
  <additive_expression> -> { <repeat_add_op_multiplicative_expression>, <multiplicative_expression> }
  <multiplicative_expression> -> { <repeat_mult_op_unary_expression>, <unary_expression> }
  <unary_expression> -> { <postfix_expression>, <pre_inc_dec>, <cast_expression>, <unary_op> }
  <pre_inc_dec> -> {  }
  <unary_op> -> {  }
  <postfix_expression> -> { <repeat_post_inc_dec>, <primary> }
  <primary> -> { <array_creation_expression>, <class_instance_creation_expression>, <reference>, <literal>, <expression>, <repeat_component> }
  <numeric_literal> -> {  }
  <character_literal> -> {  }
  <string_literal> -> {  }
  <boolean_literal> -> {  }
  <null_literal> -> {  }
  <array_creation_expression> -> { <opt_array_initializer>, <array_type_specifier> }
  <array_type_specifier> -> { <repeat_dimension+>, <type_name> }
  <repeat_dimension+> -> { <repeat_dimension>, <dimension> }
  <opt_array_initializer> -> { <array_initializer> }
  <repeat_post_inc_dec> -> { <post_inc_dec> }
  <post_inc_dec> -> {  }
  <cast_expression> -> { <lambda_expression>, <type_specifier>, <unary_expression> }
  <repeat_mult_op_unary_expression> -> { <mult_op_unary_expression> }
  <mult_op_unary_expression> -> { <unary_expression>, <mult_op> }
  <mult_op> -> {  }
  <repeat_add_op_multiplicative_expression> -> { <add_op_multiplicative_expression> }
  <add_op_multiplicative_expression> -> { <multiplicative_expression>, <add_op> }
  <add_op> -> {  }
  <repeat_shift_additive_expression> -> { <shift_additive_expression> }
  <shift_additive_expression> -> { <additive_expression>, <shift_op> }
  <shift_op> -> {  }
  <repeat_relational_op_shift_expression> -> { <relational_op_shift_expression> }
  <relational_op_shift_expression> -> { <type_specifier>, <relational_op>, <shift_expression> }
  <relational_op> -> {  }
  <repeat_equality_op_relational_expression> -> { <equality_op_relational_expression> }
  <equality_op_relational_expression> -> { <relational_expression>, <equality_op> }
  <equality_op> -> {  }
  <repeat_and_equality_expression> -> { <and_equality_expression> }
  <and_equality_expression> -> { <equality_expression> }
  <repeat_or_and_expression> -> { <or_and_expression> }
  <or_and_expression> -> { <and_expression> }
  <repeat_or_exclusive_or_expression> -> { <or_exclusive_or_expression> }
  <or_exclusive_or_expression> -> { <exclusive_or_expression> }
  <repeat_and_inclusive_or_expression> -> { <and_inclusive_or_expression> }
  <and_inclusive_or_expression> -> { <inclusive_or_expression> }
  <repeat_or_conditional_and_expression> -> { <or_conditional_and_expression> }
  <or_conditional_and_expression> -> { <conditional_and_expression> }
  <repeat_conditional_choice> -> { <conditional_choice> }
  <conditional_choice> -> { <conditional_expression>, <expression> }
  <assignment_operator> -> {  }
  <wildcard_type> -> { <opt_wildcard_type_bound> }
  <opt_wildcard_type_bound> -> { <wildcard_type_bound> }
  <wildcard_type_bound> -> { <type_specifier> }
  <class_instance_declaration> -> { <class_instance_creation_expression> }
  <opt_annotation_value_spec> -> { <annotation_value_spec> }
  <annotation_value_spec> -> { <annotation_value_list> }
  <annotation_value_list> -> { <list_keyed_annotation_value>, <annotation_value> }
  <list_keyed_annotation_value> -> { <keyed_annotation_value> }
  <keyed_annotation_value> -> { <annotation_value> }
  <package_name> -> { <qualified_name> }
  <repeat_import_declaration> -> { <import_declaration> }
  <import_declaration> -> { <imported_name>, <opt_literal> }
  <imported_name> -> { <opt_dot_star>, <package_or_type_name> }
  <package_or_type_name> -> { <qualified_name> }
  <opt_dot_star> -> { <dot_star> }
  <dot_star> -> {  }
  <repeat_type_declaration> -> { <type_declaration> }
}